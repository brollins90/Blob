using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Blob.Contracts.Command;
using Blob.Contracts.Commands;

namespace BMonitor.Handlers.Custom
{
    public class WindowsBackupCommandHandler : ICommandHandler<WindowsBackupCommand>
    {
        public void Handle(WindowsBackupCommand command)
        {
            
        }
    }
}



// http://www.dreamincode.net/forums/topic/116213-using-code-to-control-windows-back-up-restore/

//using System;
//using System.Collections.Generic;
//using System.Text;
//using System.Diagnostics;
//using System.IO;

//namespace BackUpLib
//{
//    /// <summary>
//    /// An interface object that starts processes and services through
//    /// code in a similar way to using the console command line.
//    /// </summary>
//    public class ProcessRunner
//    {   
//        private Process winProcess = new Process(); // Contains information required to start a Windows process.

//        private StreamWriter streamWriter;          // Stream writers adds input into a process.
//        private StreamReader streamReader;          // Stream readers will read the output and
//        private StreamReader streamErrors;          // errors generated by the process.

//        /// <summary>
//        /// Initialises an empty ProcessRunner object.
//        /// </summary>
//        public ProcessRunner():this("")
//        {
//        }
//        /// <summary>
//        /// Initialises a ProcessRunner object with the name of a Windows process.
//        /// </summary>
//        /// <param name="processName">The name of the Windows Process you wish to run.</param>
//        public ProcessRunner(string processName):this(processName, "")
//        {
//        }
//        /// <summary>
//        /// Initialises a ProcessRunner object with the name of a Windows process and a string of Arguments.
//        /// </summary>
//        /// <param name="processName">The name of the Windows Process you wish to run.</param>
//        /// <param name="processArgs">The string of arguments to run the process with.</param>
//        public ProcessRunner(string processName, string processArgs)
//        {
//            // Calls the final constructor with a process name, arguments and an input string
//            winProcess.StartInfo.CreateNoWindow = true;            // Hide the console window 
//            winProcess.StartInfo.UseShellExecute = false;           // do not use shell execute

//            winProcess.StartInfo.RedirectStandardInput = true;      // input and output flags
//            winProcess.StartInfo.RedirectStandardOutput = true;
//            winProcess.StartInfo.RedirectStandardError = true;

//            winProcess.StartInfo.FileName = processName;            // Add the process name
//            winProcess.StartInfo.Arguments = processArgs;           // and arguments
//        }

//        /// <summary>
//        /// Gets the name of the Windows Process.
//        /// </summary>
//        /// <returns>A string containing the Filename of the Process.</returns>
//        public string getProcessName()
//        {
//            if (winProcess.StartInfo.FileName == null)
//            {   return null;    }
//            else
//            {   return winProcess.StartInfo.FileName.ToString();    }
//        }

//        /// <summary>
//        /// Gets the string of Process Arguments.
//        /// </summary>
//        /// <returns>A string of arguments.</returns>
//        public string getProcessArgs()
//        {
//            if (winProcess.StartInfo.Arguments == null)
//            {   return null;    }
//            else
//            {   return winProcess.StartInfo.Arguments.ToString();   }
//        }

//        /*/// <summary>
//        /// Gets the sting containing the Input commands.
//        /// </summary>
//        /// <returns>A string of Input commands.</returns>
//        public string[] getProcessInput()
//        {
//            if (winProcess.StartInfo.Arguments == null)
//            {   return null;    }
//            else
//            {   return winInput;    }
//        }*/

//        /// <summary>
//        /// Sets the name of the Windows Process you wish to run.
//        /// </summary>
//        /// <param name="pName">The filename of the process with or without the extension.</param>
//        /// <returns>False if parameter has no content (is empty or null).</returns>
//        public bool setProcessName(string pName)
//        {
//            try
//            {
//                if (pName == "" || pName == null)
//                {   return false;   }
//                else
//                {
//                    winProcess.StartInfo.Arguments = pName;
//                    return true;
//                }
//            }
//            catch (Exception ex)
//            {
//                Console.WriteLine("Exception " + ex.Message);
//                return false;
//            }
//        }

//        /// <summary>
//        /// Sets the string of Arguements that would follow the Process name on the command line.
//        /// </summary>
//        /// <param name="pArgs">A string containing all the arguments you wish to run the process with.</param>
//        /// <returns>Returns false if Parameter is null, but will accept empty strings if no arguments are required.</returns>
//        public bool setProcessArgs(string pArgs)
//        {
//            try
//            {
//                if (pArgs == null)
//                {   return false;   }
//                else
//                {
//                    winProcess.StartInfo.Arguments = pArgs;
//                    return true;
//                }
//            }
//            catch (Exception ex)
//            {
//                Console.WriteLine("Exception " + ex.Message);
//                return false;
//            }
//        }
       
//        /*/// <summary>
//        /// Sets the flow of Input commands contained in a string, delimited by commas (,).
//        /// </summary>
//        /// <param name="pInput">A string containing the input commands, delimited by commas (,).</param>
//        /// <returns>Returns false if Parameter is null, but will accept empty strings if no input is required.</returns>
//        public bool setProcessInput(string pInput)
//        {
//            try
//            {
//                if (pInput == null)
//                {   return false;   }
//                else
//                {
//                    try
//                    {
//                        winInput = null;  // Add the input to the global string winInput
//                        winInput = pInput.Split(new char[] {','});
//                    }
//                    catch (Exception ex)
//                    {   Console.WriteLine(ex.Message);  }
//                    return true;
//                }
//            }
//            catch (Exception ex)
//            {
//                Console.WriteLine("Exception " + ex.Message);
//                return false;
//            }
//        }*/

//        /// <summary>
//        /// Starts the Windows Process with current settings.
//        /// </summary>
//        public void startProcess()
//        {
//            try
//            {
//                // Start the process
//                winProcess.Start();

//                // Link the Stream to the processes IO
//                streamWriter = winProcess.StandardInput;
//                streamReader = winProcess.StandardOutput;
//                streamErrors = winProcess.StandardError;
//                streamWriter.AutoFlush = true;
//            }
//            catch (Exception ex)
//            {   Console.WriteLine("Exception " + ex.Message);   }
//        }

//        /// <summary>
//        /// Using this command will call the process.Kill() method. Only necessary in certain situations.
//        /// </summary>
//        public void stopProcess()
//        {
//            try
//            {
//                winProcess.Kill();
//            }
//            catch (Exception ex)
//            {   Console.WriteLine("Exception " + ex.Message);   }
//        }

//        /// <summary>
//        /// Reads each line from the processes output and joins them together until
//        /// it encounters a line ending with a sentence ender (eg, full stop).
//        /// </summary>
//        /// <returns>The next line given by the process.</returns>
//        public string readSentence()
//        {
//            try
//            {
//                if (!winProcess.HasExited)  // Make sure process is still running
//                {
//                    bool isNotComplete = true;
//                    string fullSentence = "";
//                    string newLine = "";
//                    while (isNotComplete)
//                    {
//                        if ((newLine = streamReader.ReadLine()) != null)
//                        {
//                            fullSentence += newLine;
//                            if (newLine.Trim().EndsWith(".") || newLine.Trim().EndsWith("?") || newLine.Trim().EndsWith("!"))
//                            {
//                                isNotComplete = false;
//                            }
//                        }
//                    }
//                    return fullSentence;
//                }
//                else
//                {
//                    return null;
//                }
//            }
//            catch (Exception ex)
//            {
//                Console.WriteLine(ex.Message);
//                return null;
//            }
//        }

//        /// <summary>
//        /// Interfaces with the output of the program.
//        /// </summary>
//        /// <returns>The next line given by the process.</returns>
//        public string readLine()
//        {
//            try
//            {
//                if (!winProcess.HasExited)  // Make sure process is still running
//                {
//                    string newLine = streamReader.ReadLine();
//                    return newLine;
//                }
//                else
//                {
//                    return null;
//                }
//            }
//            catch (Exception ex)
//            {
//                Console.WriteLine(ex.Message);
//                return null;
//            }
//        }

//        /// <summary>
//        /// Interfaces with the input of the program.
//        /// </summary>
//        /// <param name="newInput">Takes an input character.</param>
//        /// <returns>True if the process is still running and false if it is not.</returns>
//        public bool writeLine(string newInput)
//        {
//            if (!winProcess.HasExited) // Make sure process is still running
//            {
//                streamWriter.WriteLine(newInput);
//                return true;
//            }
//            else
//            {
//                return false;
//            }
//        }
//    }
//}